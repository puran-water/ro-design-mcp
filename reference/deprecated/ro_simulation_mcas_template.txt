{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# RO System Simulation with MCAS Property Package and Recycle Support\n",
    "\n",
    "This notebook template combines the MCAS (Multi-Component Aqueous Solution) property package\n",
    "with recycle stream support for high recovery RO systems. It provides:\n",
    "- Ion-specific modeling and rejection calculations\n",
    "- Recycle stream implementation with proper mass balance\n",
    "- Pump pressure optimization to meet target recoveries\n",
    "- Scaling prediction and ion accumulation tracking"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "tags": [
     "parameters"
    ]
   },
   "outputs": [],
   "source": "# Parameters cell - will be replaced by papermill\nimport os\nproject_root = os.environ.get('PROJECT_ROOT', \"/path/to/project\")  # Will be replaced by papermill\nconfiguration = {}\nfeed_salinity_ppm = 5000\nfeed_temperature_c = 25.0\nmembrane_type = \"brackish\"\nmembrane_properties = None\noptimize_pumps = True\n# Ion composition in mg/L\nfeed_ion_composition = None\n# Initialization strategy\ninitialization_strategy = \"sequential\"\n# Additional parameters for environment setup\nidaes_bin_dir = \"\"  # Will be injected by papermill\npyomo_lib_path = \"\"  # Will be injected by papermill"
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": "# Import required libraries\nimport numpy as np\nimport pandas as pd\nfrom pyomo.environ import *\nfrom pyomo.network import Arc\nimport sys\nimport os\nimport platform\n\n# Add parent directory to path for utils imports using project_root parameter\nsys.path.insert(0, project_root)\n\n# Ensure PyNumero DLL can be found on Windows\nif platform.system() == \"Windows\":\n    pyomo_lib_path = os.environ.get('PYOMO_LIB_PATH',\n        os.path.join(os.path.expanduser(\"~\"), \"AppData\", \"Local\", \"Pyomo\", \"lib\"))\n    if os.path.exists(pyomo_lib_path):\n        if 'PATH' in os.environ:\n            if pyomo_lib_path not in os.environ['PATH']:\n                os.environ['PATH'] = f\"{pyomo_lib_path};{os.environ['PATH']}\"\n        else:\n            os.environ['PATH'] = pyomo_lib_path\n        print(f\"Added Pyomo lib path to PATH: {pyomo_lib_path}\")\n\n# Import our MCAS builder\nfrom utils.mcas_builder import (\n    build_mcas_property_configuration,\n    check_electroneutrality,\n    get_total_dissolved_solids,\n    calculate_ionic_strength\n)\n\n# Import our elegant initialization utilities\nfrom utils.ro_initialization import (\n    calculate_required_pressure,\n    initialize_pump_with_pressure,\n    initialize_ro_unit_elegant,\n    initialize_multistage_ro_elegant\n)\n\n# WaterTAP imports\nfrom watertap.core.solvers import get_solver\nfrom watertap.unit_models.reverse_osmosis_0D import (\n    ReverseOsmosis0D,\n    ConcentrationPolarizationType,\n    MassTransferCoefficient,\n    PressureChangeType\n)\nfrom watertap.unit_models.pressure_changer import Pump\nfrom watertap.property_models.multicomp_aq_sol_prop_pack import MCASParameterBlock\n\n# IDAES imports\nfrom idaes.core import FlowsheetBlock\nfrom idaes.core.util.scaling import calculate_scaling_factors\nfrom idaes.core.util.model_statistics import (\n    degrees_of_freedom,\n    number_unfixed_variables_in_activated_equalities,\n    number_activated_constraints\n)\nfrom idaes.core.util.initialization import propagate_state\nfrom idaes.models.unit_models import Feed, Product, Mixer, Separator\nfrom idaes.models.unit_models.mixer import MixingType, MomentumMixingType\n\nimport warnings\nwarnings.filterwarnings('ignore')\n\nimport logging\nlogging.basicConfig(level=logging.INFO)\n\n# Results storage\nresults = {}"
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Check Configuration for Recycle"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Check if recycle is configured - fixing nested structure access\n",
    "recycle_info = configuration.get('recycle_info', {})\n",
    "has_recycle = recycle_info.get('uses_recycle', False)\n",
    "recycle_ratio = recycle_info.get('recycle_ratio', 0)\n",
    "recycle_split_ratio = recycle_info.get('recycle_split_ratio', 0)\n",
    "recycle_flow_m3h = recycle_info.get('recycle_flow_m3h', 0)\n",
    "effective_feed_flow_m3h = recycle_info.get('effective_feed_flow_m3h', configuration.get('feed_flow_m3h', 0))\n",
    "\n",
    "if has_recycle:\n",
    "    print(f\"Recycle configuration detected:\")\n",
    "    print(f\"  Recycle ratio: {recycle_ratio*100:.1f}%\")\n",
    "    print(f\"  Recycle flow: {recycle_flow_m3h:.1f} m³/h\")\n",
    "    print(f\"  Recycle split ratio: {recycle_split_ratio*100:.1f}%\")\n",
    "    print(f\"  Fresh feed flow: {configuration.get('feed_flow_m3h', 0):.1f} m³/h\")\n",
    "    print(f\"  Effective feed flow: {effective_feed_flow_m3h:.1f} m³/h\")\n",
    "    print(f\"  Effective feed salinity will be calculated based on ion accumulation\")\n",
    "else:\n",
    "    print(\"No recycle configuration detected. Building standard RO model with MCAS.\")\n",
    "    print(f\"  Feed flow: {configuration.get('feed_flow_m3h', 0):.1f} m³/h\")\n",
    "    print(f\"  Feed salinity: {feed_salinity_ppm:.0f} ppm\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Define Feed Ion Composition"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": "# Import typical ion compositions from utils\nfrom utils.constants import TYPICAL_COMPOSITIONS\n\n# Use provided composition or typical based on salinity\nif feed_ion_composition is None:\n    # Scale typical composition to match target salinity\n    typical = TYPICAL_COMPOSITIONS[membrane_type]\n    typical_tds = sum(typical.values())\n    scale_factor = feed_salinity_ppm / typical_tds\n    \n    feed_ion_composition = {\n        ion: conc * scale_factor \n        for ion, conc in typical.items()\n    }\nelse:\n    # Parse JSON string if provided\n    import json\n    if isinstance(feed_ion_composition, str):\n        feed_ion_composition = json.loads(feed_ion_composition)\n\n# Check and report composition\nprint(f\"Fresh feed water composition (mg/L):\")\nfor ion, conc in sorted(feed_ion_composition.items()):\n    print(f\"  {ion:8s}: {conc:8.1f}\")\n\nactual_tds = get_total_dissolved_solids(feed_ion_composition)\nprint(f\"\\nTotal TDS: {actual_tds:.0f} mg/L\")\n\n# Check electroneutrality\nis_neutral, imbalance = check_electroneutrality(feed_ion_composition)\nif not is_neutral:\n    print(f\"\\nWarning: Charge imbalance of {imbalance:.1%}\")\n\n# Calculate ionic strength\nionic_strength = calculate_ionic_strength(feed_ion_composition)\nprint(f\"Ionic strength: {ionic_strength:.3f} mol/L\")\n\nif has_recycle:\n    print(f\"\\nNote: Effective feed composition will be higher due to recycle.\")\n    print(f\"Ion accumulation factors will be calculated during model building.\")"
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Build MCAS Property Configuration"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Build MCAS property configuration\n",
    "mcas_config = build_mcas_property_configuration(\n",
    "    feed_composition=feed_ion_composition,\n",
    "    include_scaling_ions=True,\n",
    "    include_ph_species=True\n",
    ")\n",
    "\n",
    "print(\"MCAS Configuration created with components:\")\n",
    "print(f\"  Solute list: {', '.join(mcas_config['solute_list'])}\")\n",
    "print(f\"  Activity model: {mcas_config['activity_coefficient_model']}\")\n",
    "print(f\"  Scaling ions tracked: {len(mcas_config.get('scaling_ions', {}))} types\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Build WaterTAP Model with MCAS and Recycle Support"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": "# Import the model building functions from utils\nfrom utils.ro_model_builder import build_ro_model_mcas_with_recycle\nfrom utils.ro_solver import initialize_and_solve_mcas\nfrom utils.ro_results_extractor import extract_results_mcas\n\nprint(\"Model building and solving functions imported from utils\")"
  },
  {
   "cell_type": "code",
   "source": "try:\n    # Build the model\n    print(\"Building RO model with MCAS property package...\")\n    if has_recycle:\n        print(\"Including recycle system components...\")\n    \n    model = build_ro_model_mcas_with_recycle(\n        configuration, \n        mcas_config, \n        feed_salinity_ppm,\n        feed_temperature_c, \n        membrane_type,\n        has_recycle\n    )\n    \n    print(\"\\nModel structure created successfully\")\n    print(f\"Degrees of freedom: {degrees_of_freedom(model)}\")\n    \n    # Initialize and solve\n    print(\"\\nInitializing and solving model...\")\n    print(f\"Pump optimization: {'ENABLED' if optimize_pumps else 'DISABLED'}\")\n    \n    solve_results = initialize_and_solve_mcas(model, configuration, optimize_pumps)\n    \n    if solve_results[\"status\"] == \"success\":\n        print(\"\\nModel solved successfully!\")\n        \n        # Extract results\n        print(\"\\nExtracting results...\")\n        results = extract_results_mcas(solve_results[\"model\"], configuration)\n        results[\"solve_info\"] = solve_results\n        \n        print(\"\\nSimulation completed successfully!\")\n    else:\n        results = solve_results  # Pass error info through\n        \nexcept Exception as e:\n    import traceback\n    print(f\"\\nERROR: {str(e)}\")\n    print(\"\\nFull traceback:\")\n    traceback.print_exc()\n    \n    results = {\n        \"status\": \"error\",\n        \"message\": str(e),\n        \"traceback\": traceback.format_exc(),\n        \"performance\": {},\n        \"economics\": {},\n        \"stage_results\": [],\n        \"mass_balance\": {}\n    }",
   "metadata": {},
   "execution_count": null,
   "outputs": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Display Results"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": "if results.get(\"status\") == \"success\":\n    print(\"=== SIMULATION RESULTS ===\\n\")\n    \n    # Overall performance\n    perf = results[\"performance\"]\n    print(\"Overall System Performance:\")\n    print(f\"  System Recovery: {perf['system_recovery']:.1%}\")\n    print(f\"  Permeate Flow: {perf['total_permeate_flow_m3_h']:.1f} m³/h\")\n    print(f\"  Permeate TDS: {perf['total_permeate_tds_mg_l']:.0f} mg/L\")\n    print(f\"  Total Power: {perf['total_power_consumption_kW']:.1f} kW\")\n    print(f\"  Specific Energy: {perf['specific_energy_kWh_m3']:.2f} kWh/m³\")\n    \n    # Stage results\n    print(\"\\nStage-wise Results:\")\n    print(\"Stage | Recovery | Feed P  | Perm Flow | Power\")\n    print(\"      |    (%)   | (bar)   | (m³/h)    | (kW)\")\n    print(\"-\" * 50)\n    \n    for stage in results[\"stage_results\"]:\n        print(f\"  {stage['stage']}   | {stage['recovery']*100:6.1f}  | \"\n              f\"{stage['feed_pressure_bar']:7.1f} | \"\n              f\"{stage['permeate_flow_kg_s']*3.6:9.1f} | \"\n              f\"{stage['pump_power_kW']:6.1f}\")\n    \n    # Ion tracking\n    print(\"\\nOverall Ion Rejection:\")\n    print(\"Ion     | Feed    | Permeate | Rejection\")\n    print(\"        | (mg/L)  | (mg/L)   | (%)\")\n    print(\"-\" * 45)\n    \n    for ion, data in sorted(results[\"ion_tracking\"].items()):\n        print(f\"{ion:8s}| {data['fresh_feed_mg_l']:7.1f} | \"\n              f\"{data['combined_permeate_mg_l']:8.2f} | \"\n              f\"{data['overall_rejection']*100:6.1f}\")\n    \n    # Recycle metrics if applicable\n    if has_recycle and \"recycle_metrics\" in results:\n        rm = results[\"recycle_metrics\"]\n        print(\"\\nRecycle System Metrics:\")\n        print(f\"  Recycle Split Ratio: {rm['recycle_split_ratio']*100:.1f}%\")\n        print(f\"  Recycle Flow: {rm['recycle_flow_kg_s']*3.6:.1f} m³/h\")\n        print(f\"  Disposal Flow: {rm['disposal_flow_kg_s']*3.6:.1f} m³/h\")\n        \n        print(\"\\nIon Accumulation Factors:\")\n        for ion, data in sorted(rm[\"effective_ion_composition\"].items()):\n            print(f\"  {ion}: {data['accumulation_factor']:.2f}x \"\n                  f\"(effective: {data['effective_feed_mg_l']:.0f} mg/L)\")\n    \n    # Mass balance\n    mb = results[\"mass_balance\"]\n    print(f\"\\nMass Balance Error: {mb['mass_balance_error']*100:.3f}%\")\n    print(f\"Mass Balance Check: {'PASS' if mb['mass_balance_ok'] else 'FAIL'}\")\n    \nelse:\n    print(\"=== SIMULATION ERROR ===\")\n    print(f\"Error: {results.get('message', 'Unknown error')}\")\n    if 'traceback' in results:\n        print(\"\\nTraceback:\")\n        print(results['traceback'])"
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Store results for papermill extraction\n",
    "print(\"FULL RESULTS (JSON):\")\n",
    "print(\"=\"*60)\n",
    "print(json.dumps(results, indent=2, default=str))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "tags": [
     "results"
    ]
   },
   "outputs": [],
   "source": [
    "# Results cell - tagged for papermill to extract\n",
    "results"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}